// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
// swift-module-flags: -target arm64-apple-ios16.4 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name HeadlessSDK
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Foundation
@_exported import HeadlessSDK
import Swift
import WebKit
import _Concurrency
import _StringProcessing
@_hasMissingDesignatedInitializers public class WalletCreator {
  @objc deinit
}
extension HeadlessSDK.WalletCreator : Swift.Equatable {
  public static func == (lhs: HeadlessSDK.WalletCreator, rhs: HeadlessSDK.WalletCreator) -> Swift.Bool
}
extension HeadlessSDK.WalletCreator {
  #if compiler(>=5.3) && $AsyncAwait
  public func create(passowrd: Swift.String? = nil) async throws -> HeadlessSDK.WalletCreateResponseData
  #endif
}
public struct WalletConnectResponseData : Swift.Codable {
  public let address: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WalletRpcResponseData : Swift.Codable {
  public let address: Swift.String
  public let response: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct User {
  public let id: Swift.String
  public let createdAt: Swift.Int
  public let linkedAccounts: [HeadlessSDK.LinkedAccount]
}
extension HeadlessSDK.User : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension HeadlessSDK.User : Swift.Equatable {
  public static func == (lhs: HeadlessSDK.User, rhs: HeadlessSDK.User) -> Swift.Bool
}
public enum EmbeddedWalletState {
  case connecting
  case disconnected(HeadlessSDK.WalletConnector)
  case connected(HeadlessSDK.EmbeddedWalletProvider)
  case notCreated(HeadlessSDK.WalletCreator)
  case needsRecovery(HeadlessSDK.WalletRecoverer)
  case error
}
extension HeadlessSDK.EmbeddedWalletState : Swift.Equatable {
  public static func == (lhs: HeadlessSDK.EmbeddedWalletState, rhs: HeadlessSDK.EmbeddedWalletState) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class EmbeddedWalletProvider {
  final public let address: Swift.String
  @objc deinit
}
extension HeadlessSDK.EmbeddedWalletProvider : Swift.Equatable {
  public static func == (lhs: HeadlessSDK.EmbeddedWalletProvider, rhs: HeadlessSDK.EmbeddedWalletProvider) -> Swift.Bool
}
extension HeadlessSDK.EmbeddedWalletProvider {
  #if compiler(>=5.3) && $AsyncAwait
  public func request(_ request: HeadlessSDK.EmbeddedWalletProvider.RpcRequest) async throws -> Any
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func switchChain(id: Swift.Int) async throws
  #endif
}
extension HeadlessSDK.EmbeddedWalletProvider {
  public struct RpcRequest {
    public let method: Swift.String
    public let params: [Swift.String]
  }
}
final public class Privy {
  #if compiler(>=5.3) && $AsyncAwait
  public typealias TokenProvider = () async throws -> Swift.String?
  #endif
  public typealias AuthStateChangeCallback = (HeadlessSDK.AuthState) -> Swift.Void
  final public var tokenProvider: HeadlessSDK.Privy.TokenProvider?
  final public var authState: HeadlessSDK.AuthState {
    get
  }
  final public let config: HeadlessSDK.PrivyConfig
  final public var onAuthStateChange: HeadlessSDK.Privy.AuthStateChangeCallback?
  public init(config: HeadlessSDK.PrivyConfig)
  @objc deinit
}
extension HeadlessSDK.Privy {
  #if compiler(>=5.3) && $AsyncAwait
  final public func loginWithCustomAccessToken() async throws -> HeadlessSDK.AuthState
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func refreshSession() async throws -> HeadlessSDK.AuthResponse
  #endif
  final public func logout()
}
public struct PrivyConfig {
  public let appId: Swift.String
  public var baseUrl: Swift.String
  public init(appId: Swift.String)
}
@_hasMissingDesignatedInitializers public class WalletRecoverer {
  @objc deinit
}
extension HeadlessSDK.WalletRecoverer : Swift.Equatable {
  public static func == (lhs: HeadlessSDK.WalletRecoverer, rhs: HeadlessSDK.WalletRecoverer) -> Swift.Bool
}
extension HeadlessSDK.WalletRecoverer {
  #if compiler(>=5.3) && $AsyncAwait
  public func recover(passowrd: Swift.String? = nil) async throws -> HeadlessSDK.WalletRecoverResponseData
  #endif
}
@_hasMissingDesignatedInitializers public class WalletConnector {
  @objc deinit
}
extension HeadlessSDK.WalletConnector : Swift.Equatable {
  public static func == (lhs: HeadlessSDK.WalletConnector, rhs: HeadlessSDK.WalletConnector) -> Swift.Bool
}
extension HeadlessSDK.WalletConnector {
  #if compiler(>=5.3) && $AsyncAwait
  public func connect() async throws -> HeadlessSDK.WalletConnectResponseData
  #endif
}
public struct WalletCreateResponseData : Swift.Codable {
  public let address: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct AuthResponse : Swift.Equatable {
  public let user: HeadlessSDK.User
  public let token: Swift.String
  public let refreshToken: Swift.String
  public static func == (a: HeadlessSDK.AuthResponse, b: HeadlessSDK.AuthResponse) -> Swift.Bool
}
extension HeadlessSDK.AuthResponse : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Chain {
  public let id: Swift.Int
  public let name: Swift.String
  public let network: Swift.String
  public let nativeCurrency: HeadlessSDK.Chain.NativeCurrency
  public let rpcUrls: HeadlessSDK.Chain.RpcUrls
  public let blockExplorers: HeadlessSDK.Chain.BlockExplorers
  public let contracts: HeadlessSDK.Chain.Contracts
}
extension HeadlessSDK.Chain {
  public struct NativeCurrency {
  }
}
extension HeadlessSDK.Chain {
  public struct RpcUrls {
    public struct Alchemy {
    }
    public struct Infura {
    }
    public struct Default {
    }
    public struct Public {
    }
    public let alchemy: HeadlessSDK.Chain.RpcUrls.Alchemy
    public let infura: HeadlessSDK.Chain.RpcUrls.Infura
    public let `default`: HeadlessSDK.Chain.RpcUrls.Default
    public let `public`: HeadlessSDK.Chain.RpcUrls.Public
  }
}
extension HeadlessSDK.Chain {
  public struct BlockExplorers {
    public struct Etherscan {
      public let name: Swift.String
      public let url: Swift.String
    }
    public struct Default {
      public let name: Swift.String
      public let url: Swift.String
    }
    public let etherscan: HeadlessSDK.Chain.BlockExplorers.Etherscan
    public let `default`: HeadlessSDK.Chain.BlockExplorers.Default
  }
  public struct Contracts {
    public struct Multicall3 {
      public let address: Swift.String
      public let blockCreated: Swift.Int
    }
    public let multicall3: HeadlessSDK.Chain.Contracts.Multicall3
  }
}
public struct WalletSetPasswordResponseData : Swift.Codable {
  public let address: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum LinkedAccount : Swift.Codable {
  case customAuth(HeadlessSDK.CustomAuth)
  case wallet(HeadlessSDK.Wallet)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension HeadlessSDK.LinkedAccount : Swift.Hashable, Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public static func == (lhs: HeadlessSDK.LinkedAccount, rhs: HeadlessSDK.LinkedAccount) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
public struct CustomAuth : Swift.Codable, Swift.Hashable {
  public let type: Swift.String
  public let customUserId: Swift.String
  public let verifiedAt: Foundation.TimeInterval
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: HeadlessSDK.CustomAuth, b: HeadlessSDK.CustomAuth) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct Wallet : Swift.Codable, Swift.Hashable {
  public let type: Swift.String
  public let address: Swift.String
  public let chainId: Swift.String
  public let chainType: Swift.String
  public let walletClient: Swift.String
  public let walletClientType: Swift.String
  public let connectorType: Swift.String
  public let verifiedAt: Foundation.TimeInterval
  public let recoveryMethod: Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: HeadlessSDK.Wallet, b: HeadlessSDK.Wallet) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public enum AuthState {
  case notReady
  case unauthenticated
  case authenticated(HeadlessSDK.AuthResponse, HeadlessSDK.EmbeddedWalletState)
  case error(Swift.String)
}
extension HeadlessSDK.AuthState : Swift.Equatable {
  public static func == (lhs: HeadlessSDK.AuthState, rhs: HeadlessSDK.AuthState) -> Swift.Bool
}
public enum PrivyError {
  case notReady
  case tokenError
  case timeout
  case dataParse
  case noWalletAvailable
  public static func == (a: HeadlessSDK.PrivyError, b: HeadlessSDK.PrivyError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension HeadlessSDK.PrivyError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol Account : Swift.Decodable, Swift.Equatable {
  var id: Swift.String { get }
}
public struct WalletAccount : HeadlessSDK.Account {
  public let id: Swift.String
  public let address: Swift.String
  public static func == (a: HeadlessSDK.WalletAccount, b: HeadlessSDK.WalletAccount) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct JWT {
  public init?(jwtString: Swift.String)
}
public struct WalletConnectRequest {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WalletRecoverResponseData : Swift.Codable {
  public let address: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WalletRecoverRequestData : Swift.Codable {
  public let accessToken: Swift.String
  public let address: Swift.String
  public let recoveryPassword: Swift.String?
  public init(accessToken: Swift.String, address: Swift.String, recoveryPassword: Swift.String?)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WalletRecoverRequest {
  public let id: Swift.String
  public let data: HeadlessSDK.WalletRecoverRequestData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WalletSetPasswordRequestData : Swift.Codable {
  public let accessToken: Swift.String
  public let address: Swift.String
  public let recoveryPassword: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum AccountType : Swift.String {
  case email
  case phone
  case wallet
  case googleOauth
  case twitterOauth
  case discordOauth
  case githubOauth
  case tiktokOauth
  case linkedinOauth
  case appleOauth
  case customAuth
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension HeadlessSDK.AccountType : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
}
extension HeadlessSDK.PrivyError : Swift.Equatable {}
extension HeadlessSDK.PrivyError : Swift.Hashable {}
extension HeadlessSDK.WalletConnectRequest : Swift.Encodable {}
extension HeadlessSDK.WalletConnectRequest : Swift.Decodable {}
extension HeadlessSDK.WalletRecoverRequest : Swift.Encodable {}
extension HeadlessSDK.WalletRecoverRequest : Swift.Decodable {}
extension HeadlessSDK.AccountType : Swift.Equatable {}
extension HeadlessSDK.AccountType : Swift.Hashable {}
extension HeadlessSDK.AccountType : Swift.RawRepresentable {}
